/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Cluster.ycp
 * Package:	Configuration of cluster
 * Summary:	Cluster settings, input and output functions
 * Authors:	Cong Meng <cmeng@novell.com>
 *
 * $Id: Cluster.ycp 41350 2007-10-10 16:59:00Z dfiser $
 *
 * Representation of the configuration of cluster.
 * Input and output routines.
 */

{

module "Cluster";
textdomain "cluster";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "PackageSystem";
import "SuSEFirewall";


global string csync2_key_file = "/etc/csync2/key_hagroup";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

global boolean firstrun = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
      modified = true;
  }

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

global boolean LoadClusterConfig ();

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}


global void SetAbortFunction(boolean() function) {
    AbortFunction = function;
}


// Settings: Define all variables needed for configuration of cluster
global boolean use_mgmtd = false;
global boolean secauth = false;
global string threads = "";

global string bindnetaddr1 = "";
global string mcastaddr1 = "";
global string mcastport1 = "";
global boolean enable2 = false;
global string bindnetaddr2 = "";
global string mcastaddr2 = "";
global string mcastport2 = "";

global boolean autoid = false;
global string nodeid = "";
global string rrpmode = "";

global string corokey = "";
global string csync2key = "";
global boolean global_startopenais = false;
global boolean global_startcsync2 = false;

global string transport = "";
global list<string> memberaddr1 = [];
global list<string> memberaddr2 = [];

global boolean LoadClusterConfig()
{
	if ((string)(SCR::Read(.openais.pacemaker.use_mgmtd)) == "yes") {
		use_mgmtd = true;
	} else {
		use_mgmtd = false;
	}

	if ((string)(SCR::Read(.openais.totem.secauth)) == "on") {
		secauth = true;
	} else {
		secauth = false;
	}

	threads = (string)SCR::Read(.openais.totem.threads);

	transport = (string)SCR::Read(.openais.totem.transport);
	if (transport == nil) transport = "udp";

	list <string> interfaces = (list<string>) SCR::Dir(.openais.totem.interface);
	foreach (string interface, interfaces, {
		if (interface == "interface0") {
			if (transport == "udpu") {
				memberaddr1 = splitstring((string)SCR::Read(.openais.totem.interface.interface0.member), " ");
			} else {
				mcastaddr1 = (string)SCR::Read(.openais.totem.interface.interface0.mcastaddr);
			}
			bindnetaddr1 = (string)SCR::Read(.openais.totem.interface.interface0.bindnetaddr);
			mcastport1   = (string)SCR::Read(.openais.totem.interface.interface0.mcastport);
		}

		if (interface == "interface1") {
			if (transport == "udpu") {
				memberaddr2 = splitstring((string)SCR::Read(.openais.totem.interface.interface1.member), " ");
			} else {
				mcastaddr2 = (string)SCR::Read(.openais.totem.interface.interface1.mcastaddr);
			}
			bindnetaddr2 = (string)SCR::Read(.openais.totem.interface.interface1.bindnetaddr);
			mcastport2   = (string)SCR::Read(.openais.totem.interface.interface1.mcastport);

			enable2 = true;
		}
	});

	string ai = (string)SCR::Read(.openais.totem.autoid);
	if (ai == "yes") {
		autoid = true;
	} else {
		autoid = false;
	}
	nodeid = (string)SCR::Read(.openais.totem.nodeid);

	rrpmode = (string)SCR::Read(.openais.totem.rrpmode);
	if (enable2 == false) {
		rrpmode = "none";
	} else {
		if (rrpmode != "passive" && rrpmode != "active") {
			rrpmode = "passive";
		}
	}
}

global void SaveClusterConfig()
{
	if (use_mgmtd == true) {
		SCR::Write(.openais.pacemaker.use_mgmtd, "yes");
	} else {
		SCR::Write(.openais.pacemaker.use_mgmtd, "no");
	}

	if (secauth == true) {
		SCR::Write(.openais.totem.secauth, "on");
		SCR::Write(.openais.totem.threads, threads);
	} else {
		SCR::Write(.openais.totem.secauth, "off");
		SCR::Write(.openais.totem.threads, "");
	}

	SCR::Write(.openais.totem.transport, transport);

	if (transport == "udpu") {
		SCR::Write(.openais.totem.interface.interface0.member, mergestring(memberaddr1, " "));
		SCR::Write(.openais.totem.interface.interface0.mcastaddr, "");
	} else {
		SCR::Write(.openais.totem.interface.interface0.mcastaddr, mcastaddr1);
		SCR::Write(.openais.totem.interface.interface0.member, "");
	}
	SCR::Write(.openais.totem.interface.interface0.bindnetaddr, bindnetaddr1);
	SCR::Write(.openais.totem.interface.interface0.mcastport, mcastport1);

	if (enable2 == false) {
		SCR::Write(.openais.totem.interface.interface1, "");
	} else {
		if (transport == "udpu") {
	        SCR::Write(.openais.totem.interface.interface1.member, mergestring(memberaddr2, " "));
			SCR::Write(.openais.totem.interface.interface1.mcastaddr, "");
		} else {
			SCR::Write(.openais.totem.interface.interface1.mcastaddr, mcastaddr2);
	        SCR::Write(.openais.totem.interface.interface1.member, "");
		}
		SCR::Write(.openais.totem.interface.interface1.bindnetaddr, bindnetaddr2);
		SCR::Write(.openais.totem.interface.interface1.mcastport, mcastport2);
	}

	if (autoid == true) {
		SCR::Write(.openais.totem.autoid, "yes");
		SCR::Write(.openais.totem.nodeid, "");
	} else {
		SCR::Write(.openais.totem.nodeid, nodeid);
		SCR::Write(.openais.totem.autoid, "no");
	}
	SCR::Write(.openais.totem.rrpmode, rrpmode);
	SCR::Write(.openais, "");
}

global list<string> csync2_host = [];
global list<string> csync2_include = [];

global void load_csync2_conf()
{
	csync2_host = (list<string>)SCR::Read(.csync2_ha.value.ha_group.host);
	csync2_include = (list<string>)SCR::Read(.csync2_ha.value.ha_group.include);

	if (csync2_host == nil) csync2_host = [];
	if (csync2_include == nil) csync2_include = [];
	y2milestone("read csync2 conf: csync2_host = %1", csync2_host);
	y2milestone("read csync2 conf: csync2_include = %1", csync2_include);
}

global void save_csync2_conf()
{
	y2milestone("write csync2 conf: csync2_host = %1", csync2_host);
	y2milestone("write csync2 conf: csync2_include = %1", csync2_include);

	SCR::Write(.csync2_ha.value.ha_group.host, csync2_host);
	SCR::Write(.csync2_ha.value.ha_group.include, csync2_include);
	SCR::Write(.csync2_ha.value.ha_group.key, [csync2_key_file]);

	SCR::Write(.sysconfig.pacemaker.LRMD_MAX_CHILDREN, 4);
	SCR::Write(.sysconfig.openais.COROSYNC_DEFAULT_CONFIG_IFACE, "openaisserviceenableexperimental:corosync_parser");
}

/**
 * Read all cluster settings
 * @return true on success
 */
global boolean Read() {

    /* Cluster read dialog caption */
    string caption = _("Initializing cluster Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the database"),
	    /* Progress stage 2/3 */
	    _("Read the previous settings"),
	    /* Progress stage 3/3 */
	    _("Read SuSEFirewall Settings")
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress step 2/3 */
	    _("Reading the previous settings..."),
	    /* Progress step 3/3 */
	    _("Reading SuSEFirewall settings..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    boolean ret = false;
    list<string> required_pack_list = ["pacemaker", "pacemaker-mgmt", "pacemaker-mgmt-client", "csync2"];
    ret = PackageSystem::CheckAndInstallPackagesInteractive(required_pack_list);
    if (ret == false) {
	    Report::Error(_("Cannot install required package"));
	    return false;
    }
    // read database
    if(Abort()) return false;
    SCR::Dir(.openais);
	ret = false;
	ret = LoadClusterConfig();
	if (ret == false) {
		Report::Error(_("Cannot load existing configuration"));
		return false;
	}
	if (SCR::Read(.target.size, "/etc/corosync/corosync.conf") <= 1) {
		firstrun = true;
		use_mgmtd = true; //the only interested default option
	}
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(_("Cannot read database1."));
    sleep(sl);

    load_csync2_conf();
    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(false) Report::Error(_("Cannot read database2."));
    sleep(sl);

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(Message::CannotReadCurrentSettings());
    sleep(sl);

    // detect devices
	SuSEFirewall::Read();
	if (mcastport1 != "" && SuSEFirewall::HaveService(mcastport1, "UDP", "EXT")) {
		SuSEFirewall::RemoveService(mcastport1, "UDP", "EXT");
	}
	if (enable2 && mcastport2 != "" && SuSEFirewall::HaveService(mcastport2, "UDP", "EXT")) {
		SuSEFirewall::RemoveService(mcastport2, "UDP", "EXT");
	}
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Warning(_("Cannot detect devices."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all cluster settings
 * @return true on success
 */
global boolean Write() {

    /* Cluster read dialog caption */
    string caption = _("Saving cluster Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Save changes to SuSEFirewall")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Saving changes to SuSEFirewall..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
	SaveClusterConfig();
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

	/* Work with SuSEFirewall */
	if (use_mgmtd == true) {
		SuSEFirewall::AddService("5560", "TCP", "EXT");
	} else {
		SuSEFirewall::RemoveService("5560", "TCP", "EXT");
	}
	SuSEFirewall::AddService(mcastport1, "UDP", "EXT");
	if (enable2 == true) {
		SuSEFirewall::AddService(mcastport2, "UDP", "EXT");
	}

	save_csync2_conf();

    // run SuSEconfig
	SuSEFirewall::Write();
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(false) Report::Error (Message::SuSEConfigFailed());
    sleep(sl);

	SuSEFirewall::ActivateConfiguration();
    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

	if (corokey != "") {
		map out = (map)SCR::Execute(.target.bash_output, "echo '" + corokey + "' | uudecode -o /etc/corosync/authkey");
	}
	if (csync2key != "") {
	    map out = (map)SCR::Execute(.target.bash_output, "echo '" + csync2key + "' | uudecode -o /etc/corosync/authkey");
	}
	if (global_startopenais == true) {
		SCR::Execute(.target.bash_output, "/sbin/chkconfig openais on");
	}
	if (global_startcsync2 == true) {
		SCR::Execute(.target.bash_output, "/sbin/chkconfig csync2 on");
	}

    if(Abort()) return false;
    return true;
}

/**
 * Get all cluster settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
	use_mgmtd = settings["use_mgmtd"]:true;
	secauth = settings["secauth"]:false;
	threads = settings["threads"]:"";
	bindnetaddr1 = settings["bindnetaddr1"]:"";
	mcastaddr1 = settings["mcastaddr1"]:"";
	mcastport1 = settings["mcastport1"]:"";
	enable2 = settings["enable2"]:false;
	bindnetaddr2 = settings["bindnetaddr2"]:"";
	mcastaddr2 = settings["mcastaddr2"]:"";
	mcastport2 = settings["mcastport2"]:"";
	autoid = settings["autoid"]:true;
	nodeid = "";
	rrpmode = settings["rrpmode"]:"";
	corokey = settings["corokey"]:"";
	csync2key = settings["csync2key"]:"";

	csync2_host = settings["csync2_host"]:[];
	csync2_include = settings["csync2_include"]:[];

	global_startopenais = true;
	global_startcsync2 = true;
	return true;
}

/**
 * Dump the cluster settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
	map result = $[];
	result["use_mgmtd"] = use_mgmtd;
	result["secauth"] = secauth;
	result["threads"] = threads;
	result["bindnetaddr1"] = bindnetaddr1;
	result["mcastaddr1"] = mcastaddr1;
	result["mcastport1"] = mcastport1;
	result["enable2"] = enable2;
	result["bindnetaddr2"] = bindnetaddr2;
	result["mcastaddr2"] = mcastaddr2;
	result["mcastport2"] = mcastport2;
	result["autoid"] = true;
	result["nodeid"] = "";
	result["rrpmode"] = rrpmode;
	result["csync2_host"] = csync2_host;
	result["csync2_include"] = csync2_include;
	if (SCR::Read(.target.size, "/etc/corosync/authkey") != -1) {
		map out = (map) SCR::Execute(.target.bash_output, "uuencode -m /etc/corosync/authkey /dev/stdout");
		result["corokey"] = out["stdout"]:"";
	}
	if (SCR::Read(.target.size, "/etc/csync2/key_hagroup") != -1) {
		map out = (map) SCR::Execute(.target.bash_output, "uuencode -m /etc/csync2/key_hagroup /dev/stdout ");
		result["csync2key"] = out["stdout"]:"";
	}
    return result;
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Change the configuration of HAE here..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    return $[ "install":["pacemaker-mgmt", "csync2", "pacemaker"], "remove":[] ];
}

/* EOF */
}
